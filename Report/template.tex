\documentclass[a4paper,10pt]{article}

\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage[colorlinks, allcolors=black]{hyperref}
\usepackage{geometry}
\usepackage{csvsimple}
\geometry{tmargin=3cm, bmargin=2.2cm, lmargin=2.2cm, rmargin=2cm}
\usepackage{todonotes} %Used for the figure placeholders

% Your name and student number must be filled in on the title page found in
% titlepage.tex.

\begin{document}
\input{titlepage}

\tableofcontents
\newpage

\section{Introduction}\label{sec:introduction}
We needed to design an algorithm that is capable of automatically segmenting the 8 incisors on a radiograph.
To accomplish this we were provided with 14 radiographs with the landmarks for each incisor. We used these landmarks to make a active shape model, section \ref{sec:alignment}. Before using these models for fitting the incisors of other radiographs, we made a method to find an initial guess for each incisor, section \ref{sec:initial}. When we have found the initial position, we then use the active shape models to fit to the incisors on the image, section \ref{sec:fit}. We tried different fitting algorithms, multiple variations of an energy based algorithm, section \ref{sec:fit_energy} and one profile based algorithm, section \ref{sec:fit_deriv}. When implementing these algorithms we encountered some problems with convergence, section \ref{sec:convergence}. After some experimentation we decided that the profile based algorithm gave the best results and thus we used this algorithm to do some more extensive tests, section \ref{sec:results}.


\section{Alignment} \label{sec:alignment}
To be able to combine all the different landmarks of each incisor they need to be comparable (same center, similar scale and rotation). We realigned the landmarks so they the same center, rotation and scale. To accomplish this we used Procrustes Analysis as described in protocol 4 of \cite{TemplateAlgorithm}. Convergence in step 7 of this protocol is achieved if every element of the new result differs at most 0.01 from the result of the previous iteration.

\section{Convergence}\label{sec:convergence}
When testing the different algorithms, we encountered a problem with the fitting of our contours: it didn't convergence completely. To solve this we first were a bit lenient about when convergence happened: if less than 10\% of the points describing the contour changed, we considered this converged. This approach gave us some better results, but it didn't solve the problem completely. We thought that the contours endlessly cycled between certain states. We solved this by introducing an extra condition: if each point of the contour changed at most 10 pixels in every 50 iterations, we considered this converged. This new condition guaranteed termination of the algorithm. 

A second observation we made was that the contour would move outside the bounds of a reasonable solution. When this occurs, we would stop the execution of the fitting and consider the current result as best fit. We consider the bounds of a reasonable solution as a rectangle with trice the width and 140\% the height of the initial rectangle found as initial position, see section \ref{sec:initial}.

%figure

\section{Initializing starting position}\label{sec:initial}
Before we can try to fit our model to the image, we need to find an initial estimate of the incisors. We decided to use PCA to find the estimate.
To make sure teeth aren't confused with each other we decided to group the upper and lower incisors in two different groups and search for each group independently. This means that we extract two cropped images, respectively of the four upper and lower incisors. In figures \ref{fig:PCAupper} and \ref{fig:PCAlower} we show the results of both PCA procedures.

To limit the amount of comparisons to be done and attain reasonable solutions, we can limit the search space to the central area of each image, since the incisors only reside there. The areas for both upper and lower incisors are displayed in figure \ref{fig:PCAsearch}.

To extract an estimate for each tooth, we simply divide the found result in four equally long parts, figure \ref{fig:split4}. Even though it is not precise, we decided that it would be good enough as an initial estimate.

\section{Contour fitting}\label{sec:fit}
After finding the initial estimate of an incisor, we then have to fit the estimate to image. We tried four different approaches to this particular problem. The first one is based on using the nearest edges, second and third one are based on an energy function and the fourth one is based on profiles. Although they are slightly different, they still all follow the same algorithm: the active shape model algorithm described in protocol 2 from \cite{TemplateAlgorithm}.

\subsection{Nearest edge based}\label{sec:fit_edge}
The first approach was to iteratively examine the area of each model point and calculate the distance to the nearest edge. We then moved each model point to it's best neighbor with the lowest distance. Then we mapped the model generated by the PCA to our found points as described in \cite{GenerateModel}. This was done until the contour converged. The edges were found by using the canny operator provided by opencv \cite{Canny}. To reduce noise we have tested a variety of filters:  GaussianBlur, MedianBlur and bilateralFilter\cite{PythonFilters}. A problem that arose was that the incisor had an internal edge around the crown \ref{fig:InternalEdge} and that the edges around the roots were weak. We tried to solve this by processing the root and crown differently but to no avail.

\subsection{Energy based}\label{sec:fit_energy}
The second and third approaches are energy based. We examine the area around each point and search for the point that will result in the lowest total energy for the entire contour. To efficiently find the lowest, we used the Viterbi algorithm. After finding the nearest contour with the lowest energy, we map the model generated PCA to the found contour. This is repeated until the contour converges.

The energy is divided in two parts: internal and external energy. The internal energy is defined by the formula used in the course, stiffness and elasticity. For the external energy we tried two different functions, which is the only difference between the two approaches.

\subsubsection{Gradient size based}
Our first energy based approach uses the same external energy function as seen in the course:
\begin{equation}
E_{external}(v) = - ( |G_{x}(v)|^2 + |G_{y}(v)|^2 )
\end{equation}

This function is only based on the magnitude of the gradients.

\subsubsection{Orientated gradient size based}
Our second energy based approach uses an external function we found in \cite{OrientatedEnergy}. 
\begin{equation}
E_{external}(v) = -  \|G(v)\|cos(\theta_{G}(v) - \theta_{N}(v))\\
\end{equation}

In this equation we use $\theta_{G}(v)$, the gradient direction at v, and $\theta_{N}(v)$, the contour's normal direction at v. These direction will decide in which direction the point will be pushed. When $\theta_{G}(v)$ is in the same direction as  $\theta_{N}(v)$ the point will be pushed in the direction normal, if not it will be pushed in the opposite. We hoped to benefit by using the direction of the gradient, which should always be toward the exterior of an incisor. It would eliminate the possibility of using the edges of neighboring teeth.

\subsection{Profile based}\label{sec:fit_deriv}
For our last approach we use the profile method from \cite{TemplateAlgorithm}. To improve the position of points, we look along profiles normal to the boundary of the contour. To lose the effect of global intensity changes we take the derivative along the profile and normalize it. We sample profiles from the training set and build a statistical structure, mean($\overline{g}$) and covariance($S_{g}$), for each point. This structure will be used to find the most similar position along the profile. The similarity is based on the quality of the fit:
\begin{equation}
f(g_{s}) = (g_{s} - \overline{g}) S_{g}^{-1} (g_{s}-\overline{g})
\end{equation}

The profiles we take from the training set contains 5 pixels in each direction along the normal, which results in a profile of length 11. When we try to find the best position we take a profile at the current point containing 10 pixels in each direction, profile length 21. We then sample parts of length 11 from this profile and from these samples we find the most similar one. The center pixel of the most similar sample will be picked as the new point.

\section{Results}\label{sec:results}

\begin{table}
\begin{center}
\csvautotabular{Tabel_leaveone.csv}
\caption{Leave-one-out analasys}
\end{center}
\end{table}

\section{Conclusion}


\section{References}
\bibliographystyle{plain}
\bibliography{bib}

\end{document}
